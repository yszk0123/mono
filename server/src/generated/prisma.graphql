# THIS FILE HAS BEEN AUTO-GENERATED BY "PRISMA DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Book implements Node {
  id: ID!
  title: String!
  author: String
  createdBy(where: UserWhereInput): User!
}

type Link implements Node {
  id: ID!
  uri: String!
  createdBy(where: UserWhereInput): User!
}

type Member implements Node {
  id: ID!
  name: String!
  createdBy(where: UserWhereInput): User!
}

type Note implements Node {
  id: ID!
  title: String
  text: String!
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  members(where: MemberWhereInput, orderBy: MemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Member!]
  links(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Link!]
  createdAt: DateTime!
  createdBy(where: UserWhereInput): User!
  date: DateTime
}

type Tag implements Node {
  id: ID!
  text: String!
  category(where: TagWhereInput): Tag
  createdBy(where: UserWhereInput): User!
}

type User implements Node {
  id: ID!
  email: String!
  password: String!
  name: String!
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  members(where: MemberWhereInput, orderBy: MemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Member!]
  links(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Link!]
  books(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Book!]
}


#
# Other Types
#

type AggregateBook {
  count: Int!
}

type AggregateLink {
  count: Int!
}

type AggregateMember {
  count: Int!
}

type AggregateNote {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type BookConnection {
  pageInfo: PageInfo!
  edges: [BookEdge]!
  aggregate: AggregateBook!
}

input BookCreateInput {
  title: String!
  author: String
  createdBy: UserCreateOneWithoutBooksInput!
}

input BookCreateManyWithoutCreatedByInput {
  create: [BookCreateWithoutCreatedByInput!]
  connect: [BookWhereUniqueInput!]
}

input BookCreateWithoutCreatedByInput {
  title: String!
  author: String
}

type BookEdge {
  node: Book!
  cursor: String!
}

enum BookOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  author_ASC
  author_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BookPreviousValues {
  id: ID!
  title: String!
  author: String
}

type BookSubscriptionPayload {
  mutation: MutationType!
  node: Book
  updatedFields: [String!]
  previousValues: BookPreviousValues
}

input BookSubscriptionWhereInput {
  AND: [BookSubscriptionWhereInput!]
  OR: [BookSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookWhereInput
}

input BookUpdateInput {
  title: String
  author: String
  createdBy: UserUpdateOneWithoutBooksInput
}

input BookUpdateManyWithoutCreatedByInput {
  create: [BookCreateWithoutCreatedByInput!]
  connect: [BookWhereUniqueInput!]
  disconnect: [BookWhereUniqueInput!]
  delete: [BookWhereUniqueInput!]
  update: [BookUpdateWithoutCreatedByInput!]
  upsert: [BookUpsertWithoutCreatedByInput!]
}

input BookUpdateWithoutCreatedByDataInput {
  title: String
  author: String
}

input BookUpdateWithoutCreatedByInput {
  where: BookWhereUniqueInput!
  data: BookUpdateWithoutCreatedByDataInput!
}

input BookUpsertWithoutCreatedByInput {
  where: BookWhereUniqueInput!
  update: BookUpdateWithoutCreatedByDataInput!
  create: BookCreateWithoutCreatedByInput!
}

input BookWhereInput {
  AND: [BookWhereInput!]
  OR: [BookWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  author: String
  author_not: String
  author_in: [String!]
  author_not_in: [String!]
  author_lt: String
  author_lte: String
  author_gt: String
  author_gte: String
  author_contains: String
  author_not_contains: String
  author_starts_with: String
  author_not_starts_with: String
  author_ends_with: String
  author_not_ends_with: String
  createdBy: UserWhereInput
}

input BookWhereUniqueInput {
  id: ID
}

scalar DateTime

type LinkConnection {
  pageInfo: PageInfo!
  edges: [LinkEdge]!
  aggregate: AggregateLink!
}

input LinkCreateInput {
  uri: String!
  createdBy: UserCreateOneWithoutLinksInput!
}

input LinkCreateManyInput {
  create: [LinkCreateInput!]
  connect: [LinkWhereUniqueInput!]
}

input LinkCreateManyWithoutCreatedByInput {
  create: [LinkCreateWithoutCreatedByInput!]
  connect: [LinkWhereUniqueInput!]
}

input LinkCreateWithoutCreatedByInput {
  uri: String!
}

type LinkEdge {
  node: Link!
  cursor: String!
}

enum LinkOrderByInput {
  id_ASC
  id_DESC
  uri_ASC
  uri_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type LinkPreviousValues {
  id: ID!
  uri: String!
}

type LinkSubscriptionPayload {
  mutation: MutationType!
  node: Link
  updatedFields: [String!]
  previousValues: LinkPreviousValues
}

input LinkSubscriptionWhereInput {
  AND: [LinkSubscriptionWhereInput!]
  OR: [LinkSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LinkWhereInput
}

input LinkUpdateInput {
  uri: String
  createdBy: UserUpdateOneWithoutLinksInput
}

input LinkUpdateManyInput {
  create: [LinkCreateInput!]
  connect: [LinkWhereUniqueInput!]
  disconnect: [LinkWhereUniqueInput!]
  delete: [LinkWhereUniqueInput!]
}

input LinkUpdateManyWithoutCreatedByInput {
  create: [LinkCreateWithoutCreatedByInput!]
  connect: [LinkWhereUniqueInput!]
  disconnect: [LinkWhereUniqueInput!]
  delete: [LinkWhereUniqueInput!]
  update: [LinkUpdateWithoutCreatedByInput!]
  upsert: [LinkUpsertWithoutCreatedByInput!]
}

input LinkUpdateWithoutCreatedByDataInput {
  uri: String
}

input LinkUpdateWithoutCreatedByInput {
  where: LinkWhereUniqueInput!
  data: LinkUpdateWithoutCreatedByDataInput!
}

input LinkUpsertWithoutCreatedByInput {
  where: LinkWhereUniqueInput!
  update: LinkUpdateWithoutCreatedByDataInput!
  create: LinkCreateWithoutCreatedByInput!
}

input LinkWhereInput {
  AND: [LinkWhereInput!]
  OR: [LinkWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  uri: String
  uri_not: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_gt: String
  uri_gte: String
  uri_contains: String
  uri_not_contains: String
  uri_starts_with: String
  uri_not_starts_with: String
  uri_ends_with: String
  uri_not_ends_with: String
  createdBy: UserWhereInput
}

input LinkWhereUniqueInput {
  id: ID
  uri: String
}

scalar Long

type MemberConnection {
  pageInfo: PageInfo!
  edges: [MemberEdge]!
  aggregate: AggregateMember!
}

input MemberCreateInput {
  name: String!
  createdBy: UserCreateOneWithoutMembersInput!
}

input MemberCreateManyInput {
  create: [MemberCreateInput!]
  connect: [MemberWhereUniqueInput!]
}

input MemberCreateManyWithoutCreatedByInput {
  create: [MemberCreateWithoutCreatedByInput!]
  connect: [MemberWhereUniqueInput!]
}

input MemberCreateWithoutCreatedByInput {
  name: String!
}

type MemberEdge {
  node: Member!
  cursor: String!
}

enum MemberOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type MemberPreviousValues {
  id: ID!
  name: String!
}

type MemberSubscriptionPayload {
  mutation: MutationType!
  node: Member
  updatedFields: [String!]
  previousValues: MemberPreviousValues
}

input MemberSubscriptionWhereInput {
  AND: [MemberSubscriptionWhereInput!]
  OR: [MemberSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MemberWhereInput
}

input MemberUpdateInput {
  name: String
  createdBy: UserUpdateOneWithoutMembersInput
}

input MemberUpdateManyInput {
  create: [MemberCreateInput!]
  connect: [MemberWhereUniqueInput!]
  disconnect: [MemberWhereUniqueInput!]
  delete: [MemberWhereUniqueInput!]
}

input MemberUpdateManyWithoutCreatedByInput {
  create: [MemberCreateWithoutCreatedByInput!]
  connect: [MemberWhereUniqueInput!]
  disconnect: [MemberWhereUniqueInput!]
  delete: [MemberWhereUniqueInput!]
  update: [MemberUpdateWithoutCreatedByInput!]
  upsert: [MemberUpsertWithoutCreatedByInput!]
}

input MemberUpdateWithoutCreatedByDataInput {
  name: String
}

input MemberUpdateWithoutCreatedByInput {
  where: MemberWhereUniqueInput!
  data: MemberUpdateWithoutCreatedByDataInput!
}

input MemberUpsertWithoutCreatedByInput {
  where: MemberWhereUniqueInput!
  update: MemberUpdateWithoutCreatedByDataInput!
  create: MemberCreateWithoutCreatedByInput!
}

input MemberWhereInput {
  AND: [MemberWhereInput!]
  OR: [MemberWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdBy: UserWhereInput
}

input MemberWhereUniqueInput {
  id: ID
}

type Mutation {
  createNote(data: NoteCreateInput!): Note!
  createTag(data: TagCreateInput!): Tag!
  createMember(data: MemberCreateInput!): Member!
  createBook(data: BookCreateInput!): Book!
  createLink(data: LinkCreateInput!): Link!
  createUser(data: UserCreateInput!): User!
  updateNote(data: NoteUpdateInput!, where: NoteWhereUniqueInput!): Note
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateMember(data: MemberUpdateInput!, where: MemberWhereUniqueInput!): Member
  updateBook(data: BookUpdateInput!, where: BookWhereUniqueInput!): Book
  updateLink(data: LinkUpdateInput!, where: LinkWhereUniqueInput!): Link
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  deleteNote(where: NoteWhereUniqueInput!): Note
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteMember(where: MemberWhereUniqueInput!): Member
  deleteBook(where: BookWhereUniqueInput!): Book
  deleteLink(where: LinkWhereUniqueInput!): Link
  deleteUser(where: UserWhereUniqueInput!): User
  upsertNote(where: NoteWhereUniqueInput!, create: NoteCreateInput!, update: NoteUpdateInput!): Note!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  upsertMember(where: MemberWhereUniqueInput!, create: MemberCreateInput!, update: MemberUpdateInput!): Member!
  upsertBook(where: BookWhereUniqueInput!, create: BookCreateInput!, update: BookUpdateInput!): Book!
  upsertLink(where: LinkWhereUniqueInput!, create: LinkCreateInput!, update: LinkUpdateInput!): Link!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  updateManyNotes(data: NoteUpdateInput!, where: NoteWhereInput!): BatchPayload!
  updateManyTags(data: TagUpdateInput!, where: TagWhereInput!): BatchPayload!
  updateManyMembers(data: MemberUpdateInput!, where: MemberWhereInput!): BatchPayload!
  updateManyBooks(data: BookUpdateInput!, where: BookWhereInput!): BatchPayload!
  updateManyLinks(data: LinkUpdateInput!, where: LinkWhereInput!): BatchPayload!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload!
  deleteManyNotes(where: NoteWhereInput!): BatchPayload!
  deleteManyTags(where: TagWhereInput!): BatchPayload!
  deleteManyMembers(where: MemberWhereInput!): BatchPayload!
  deleteManyBooks(where: BookWhereInput!): BatchPayload!
  deleteManyLinks(where: LinkWhereInput!): BatchPayload!
  deleteManyUsers(where: UserWhereInput!): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type NoteConnection {
  pageInfo: PageInfo!
  edges: [NoteEdge]!
  aggregate: AggregateNote!
}

input NoteCreateInput {
  title: String
  text: String!
  date: DateTime
  tags: TagCreateManyInput
  members: MemberCreateManyInput
  links: LinkCreateManyInput
  createdBy: UserCreateOneWithoutNotesInput!
}

input NoteCreateManyWithoutCreatedByInput {
  create: [NoteCreateWithoutCreatedByInput!]
  connect: [NoteWhereUniqueInput!]
}

input NoteCreateWithoutCreatedByInput {
  title: String
  text: String!
  date: DateTime
  tags: TagCreateManyInput
  members: MemberCreateManyInput
  links: LinkCreateManyInput
}

type NoteEdge {
  node: Note!
  cursor: String!
}

enum NoteOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  date_ASC
  date_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NotePreviousValues {
  id: ID!
  title: String
  text: String!
  createdAt: DateTime!
  date: DateTime
}

type NoteSubscriptionPayload {
  mutation: MutationType!
  node: Note
  updatedFields: [String!]
  previousValues: NotePreviousValues
}

input NoteSubscriptionWhereInput {
  AND: [NoteSubscriptionWhereInput!]
  OR: [NoteSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NoteWhereInput
}

input NoteUpdateInput {
  title: String
  text: String
  date: DateTime
  tags: TagUpdateManyInput
  members: MemberUpdateManyInput
  links: LinkUpdateManyInput
  createdBy: UserUpdateOneWithoutNotesInput
}

input NoteUpdateManyWithoutCreatedByInput {
  create: [NoteCreateWithoutCreatedByInput!]
  connect: [NoteWhereUniqueInput!]
  disconnect: [NoteWhereUniqueInput!]
  delete: [NoteWhereUniqueInput!]
  update: [NoteUpdateWithoutCreatedByInput!]
  upsert: [NoteUpsertWithoutCreatedByInput!]
}

input NoteUpdateWithoutCreatedByDataInput {
  title: String
  text: String
  date: DateTime
  tags: TagUpdateManyInput
  members: MemberUpdateManyInput
  links: LinkUpdateManyInput
}

input NoteUpdateWithoutCreatedByInput {
  where: NoteWhereUniqueInput!
  data: NoteUpdateWithoutCreatedByDataInput!
}

input NoteUpsertWithoutCreatedByInput {
  where: NoteWhereUniqueInput!
  update: NoteUpdateWithoutCreatedByDataInput!
  create: NoteCreateWithoutCreatedByInput!
}

input NoteWhereInput {
  AND: [NoteWhereInput!]
  OR: [NoteWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  members_every: MemberWhereInput
  members_some: MemberWhereInput
  members_none: MemberWhereInput
  links_every: LinkWhereInput
  links_some: LinkWhereInput
  links_none: LinkWhereInput
  createdBy: UserWhereInput
}

input NoteWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note]!
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  members(where: MemberWhereInput, orderBy: MemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Member]!
  books(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Book]!
  links(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Link]!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  note(where: NoteWhereUniqueInput!): Note
  tag(where: TagWhereUniqueInput!): Tag
  member(where: MemberWhereUniqueInput!): Member
  book(where: BookWhereUniqueInput!): Book
  link(where: LinkWhereUniqueInput!): Link
  user(where: UserWhereUniqueInput!): User
  notesConnection(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NoteConnection!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  membersConnection(where: MemberWhereInput, orderBy: MemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MemberConnection!
  booksConnection(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookConnection!
  linksConnection(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LinkConnection!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  note(where: NoteSubscriptionWhereInput): NoteSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  member(where: MemberSubscriptionWhereInput): MemberSubscriptionPayload
  book(where: BookSubscriptionWhereInput): BookSubscriptionPayload
  link(where: LinkSubscriptionWhereInput): LinkSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  text: String!
  category: TagCreateOneWithoutCategoryInput
  createdBy: UserCreateOneWithoutTagsInput!
}

input TagCreateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateManyWithoutCreatedByInput {
  create: [TagCreateWithoutCreatedByInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateOneWithoutCategoryInput {
  create: TagCreateWithoutCategoryInput
  connect: TagWhereUniqueInput
}

input TagCreateWithoutCategoryInput {
  text: String!
  createdBy: UserCreateOneWithoutTagsInput!
}

input TagCreateWithoutCreatedByInput {
  text: String!
  category: TagCreateOneWithoutCategoryInput
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TagPreviousValues {
  id: ID!
  text: String!
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
}

input TagUpdateInput {
  text: String
  category: TagUpdateOneWithoutCategoryInput
  createdBy: UserUpdateOneWithoutTagsInput
}

input TagUpdateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  delete: [TagWhereUniqueInput!]
}

input TagUpdateManyWithoutCreatedByInput {
  create: [TagCreateWithoutCreatedByInput!]
  connect: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  delete: [TagWhereUniqueInput!]
  update: [TagUpdateWithoutCreatedByInput!]
  upsert: [TagUpsertWithoutCreatedByInput!]
}

input TagUpdateOneWithoutCategoryInput {
  create: TagCreateWithoutCategoryInput
  connect: TagWhereUniqueInput
  disconnect: TagWhereUniqueInput
  delete: TagWhereUniqueInput
  update: TagUpdateWithoutCategoryInput
  upsert: TagUpsertWithoutCategoryInput
}

input TagUpdateWithoutCategoryDataInput {
  text: String
  createdBy: UserUpdateOneWithoutTagsInput
}

input TagUpdateWithoutCategoryInput {
  where: TagWhereUniqueInput!
  data: TagUpdateWithoutCategoryDataInput!
}

input TagUpdateWithoutCreatedByDataInput {
  text: String
  category: TagUpdateOneWithoutCategoryInput
}

input TagUpdateWithoutCreatedByInput {
  where: TagWhereUniqueInput!
  data: TagUpdateWithoutCreatedByDataInput!
}

input TagUpsertWithoutCategoryInput {
  where: TagWhereUniqueInput!
  update: TagUpdateWithoutCategoryDataInput!
  create: TagCreateWithoutCategoryInput!
}

input TagUpsertWithoutCreatedByInput {
  where: TagWhereUniqueInput!
  update: TagUpdateWithoutCreatedByDataInput!
  create: TagCreateWithoutCreatedByInput!
}

input TagWhereInput {
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  category: TagWhereInput
  createdBy: UserWhereInput
}

input TagWhereUniqueInput {
  id: ID
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String!
  password: String!
  name: String!
  notes: NoteCreateManyWithoutCreatedByInput
  tags: TagCreateManyWithoutCreatedByInput
  members: MemberCreateManyWithoutCreatedByInput
  links: LinkCreateManyWithoutCreatedByInput
  books: BookCreateManyWithoutCreatedByInput
}

input UserCreateOneWithoutBooksInput {
  create: UserCreateWithoutBooksInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutLinksInput {
  create: UserCreateWithoutLinksInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMembersInput {
  create: UserCreateWithoutMembersInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutNotesInput {
  create: UserCreateWithoutNotesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTagsInput {
  create: UserCreateWithoutTagsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutBooksInput {
  email: String!
  password: String!
  name: String!
  notes: NoteCreateManyWithoutCreatedByInput
  tags: TagCreateManyWithoutCreatedByInput
  members: MemberCreateManyWithoutCreatedByInput
  links: LinkCreateManyWithoutCreatedByInput
}

input UserCreateWithoutLinksInput {
  email: String!
  password: String!
  name: String!
  notes: NoteCreateManyWithoutCreatedByInput
  tags: TagCreateManyWithoutCreatedByInput
  members: MemberCreateManyWithoutCreatedByInput
  books: BookCreateManyWithoutCreatedByInput
}

input UserCreateWithoutMembersInput {
  email: String!
  password: String!
  name: String!
  notes: NoteCreateManyWithoutCreatedByInput
  tags: TagCreateManyWithoutCreatedByInput
  links: LinkCreateManyWithoutCreatedByInput
  books: BookCreateManyWithoutCreatedByInput
}

input UserCreateWithoutNotesInput {
  email: String!
  password: String!
  name: String!
  tags: TagCreateManyWithoutCreatedByInput
  members: MemberCreateManyWithoutCreatedByInput
  links: LinkCreateManyWithoutCreatedByInput
  books: BookCreateManyWithoutCreatedByInput
}

input UserCreateWithoutTagsInput {
  email: String!
  password: String!
  name: String!
  notes: NoteCreateManyWithoutCreatedByInput
  members: MemberCreateManyWithoutCreatedByInput
  links: LinkCreateManyWithoutCreatedByInput
  books: BookCreateManyWithoutCreatedByInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  name: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  notes: NoteUpdateManyWithoutCreatedByInput
  tags: TagUpdateManyWithoutCreatedByInput
  members: MemberUpdateManyWithoutCreatedByInput
  links: LinkUpdateManyWithoutCreatedByInput
  books: BookUpdateManyWithoutCreatedByInput
}

input UserUpdateOneWithoutBooksInput {
  create: UserCreateWithoutBooksInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutBooksInput
  upsert: UserUpsertWithoutBooksInput
}

input UserUpdateOneWithoutLinksInput {
  create: UserCreateWithoutLinksInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutLinksInput
  upsert: UserUpsertWithoutLinksInput
}

input UserUpdateOneWithoutMembersInput {
  create: UserCreateWithoutMembersInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutMembersInput
  upsert: UserUpsertWithoutMembersInput
}

input UserUpdateOneWithoutNotesInput {
  create: UserCreateWithoutNotesInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutNotesInput
  upsert: UserUpsertWithoutNotesInput
}

input UserUpdateOneWithoutTagsInput {
  create: UserCreateWithoutTagsInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutTagsInput
  upsert: UserUpsertWithoutTagsInput
}

input UserUpdateWithoutBooksDataInput {
  email: String
  password: String
  name: String
  notes: NoteUpdateManyWithoutCreatedByInput
  tags: TagUpdateManyWithoutCreatedByInput
  members: MemberUpdateManyWithoutCreatedByInput
  links: LinkUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutBooksInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutBooksDataInput!
}

input UserUpdateWithoutLinksDataInput {
  email: String
  password: String
  name: String
  notes: NoteUpdateManyWithoutCreatedByInput
  tags: TagUpdateManyWithoutCreatedByInput
  members: MemberUpdateManyWithoutCreatedByInput
  books: BookUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutLinksInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutLinksDataInput!
}

input UserUpdateWithoutMembersDataInput {
  email: String
  password: String
  name: String
  notes: NoteUpdateManyWithoutCreatedByInput
  tags: TagUpdateManyWithoutCreatedByInput
  links: LinkUpdateManyWithoutCreatedByInput
  books: BookUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutMembersInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutMembersDataInput!
}

input UserUpdateWithoutNotesDataInput {
  email: String
  password: String
  name: String
  tags: TagUpdateManyWithoutCreatedByInput
  members: MemberUpdateManyWithoutCreatedByInput
  links: LinkUpdateManyWithoutCreatedByInput
  books: BookUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutNotesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutNotesDataInput!
}

input UserUpdateWithoutTagsDataInput {
  email: String
  password: String
  name: String
  notes: NoteUpdateManyWithoutCreatedByInput
  members: MemberUpdateManyWithoutCreatedByInput
  links: LinkUpdateManyWithoutCreatedByInput
  books: BookUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutTagsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutTagsDataInput!
}

input UserUpsertWithoutBooksInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutBooksDataInput!
  create: UserCreateWithoutBooksInput!
}

input UserUpsertWithoutLinksInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutLinksDataInput!
  create: UserCreateWithoutLinksInput!
}

input UserUpsertWithoutMembersInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutMembersDataInput!
  create: UserCreateWithoutMembersInput!
}

input UserUpsertWithoutNotesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutNotesDataInput!
  create: UserCreateWithoutNotesInput!
}

input UserUpsertWithoutTagsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutTagsDataInput!
  create: UserCreateWithoutTagsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  notes_every: NoteWhereInput
  notes_some: NoteWhereInput
  notes_none: NoteWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  members_every: MemberWhereInput
  members_some: MemberWhereInput
  members_none: MemberWhereInput
  links_every: LinkWhereInput
  links_some: LinkWhereInput
  links_none: LinkWhereInput
  books_every: BookWhereInput
  books_some: BookWhereInput
  books_none: BookWhereInput
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
